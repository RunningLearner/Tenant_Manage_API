# 2번째 과제: 자동차 경주 게임 만들기

C#으로 자동차 경주 게임을 즐길 수 있는 콘솔 프로그램을 제작해야 한다.

## 과제 수행 절차

1. 이 Git 저장소를 자기 PC로 Clone하여, `[사내ID]-02` 브랜치로 Checkout한다.
2. 해당 브랜치에서 기능 요구사항을 만족하는 프로그램을 작성한다.
3. 기능 요구사항을 모두 만족했으면, 이제 비기능적 요구사항도 모두 충족할 때까지 코드를 수정한다.
4. 모든 요구사항을 해결했으면, 코드를 서버에 Push한다.
5. `[사내ID]-02-result` 이름으로 된 브랜치를 대상으로 Pull Request를 작성한다.
6. Pull Request를 통해 강사의 코드 리뷰를 받고 피드백에 따라 수정한다.
7. 리뷰어가 PR을 승인하여 Pull Request가 통과되면 과제 완료.

## 기능 요구사항

- 여러 대의 자동차를 경주시켜, 제한된 시도 횟수 내에서 가장 멀리 나간 자동차를 결정하는 게임을 구현한다.
- 각 자동차에는 최대 5글자까지의 이름을 부여한다.
- 자동차의 이름을 입력받을 때, 각 자동차 이름은 쉼표(`,`)를 기준으로 구분한다.
- 자동차 이름을 입력한 뒤, 전진을 모두 몇 번 시도할 것인지 사용자로부터 횟수를 입력받는다.
- 전진을 시도할 때마다 컴퓨터는 각 자동차에 대해 0에서 9 사이의 임의의 정수 값을 구하여, 값이 5 이상인 경우에 해당 자동차를 1칸 전진시킨다.
- 모든 전진 시도가 끝났을 때, 각 차량의 이름과 해당 차량의 전진 정도를 dash(`-`)로 화면에 표시한다.
- 실행 결과를 표시할 때, 각 전진 시도 사이는 빈 줄 1칸으로 띄운다.
- 모든 전진 시도가 끝나면, 가장 멀리 전진한 자동차를 우승자로 선정하여 화면에 표시한다.
- 우승한 자동차는 한 대가 아니라 여러 대일 수도 있다.

## 비기능적 요구사항

- 다음과 같이 제시된 `Car` 클래스를 사용해야 한다.
  - 아래와 같이 미리 준비된 초기 코드로 시작해야 한다.
    ```csharp
    public class Car
    {
        private readonly string name;
        private int position = 0;

        public Car(string name)
        {
            this.name = name;
        }
    }
    ```
  - 이 클래스의 기본 생성자는 제시된 코드 외에 따로 추가할 수 없다.
  - `name` 및 `position` 변수의 `private` 접근 제어자는 바꿀 수 없다.
  - 외부에서 정수 값을 받아와서 `position` 변수를 직접 바꾸는 Setter 메소드는 구현할 수 없다.
- 새로 클래스를 정의할 때는 반드시 별도의 파일을 새로 생성하여 정의해야 한다.
- 각 메소드 안에서 들여쓰기는 최대 2단계(공백 8칸)까지만 허용한다.
  - 메소드를 이루는 대괄호(`{ }`) 안의 들여쓰기 단계를 0단계로 본다.
  - 예를 들어 메소드 안에서 `for { }`문을 사용하면 해당 문의 대괄호 안쪽 들여쓰기 단계는 1단계이다.
  - 그러면 `for { }`문 안에서 다시 `if { }`문을 사용하면 `if { }`문의 대괄호 안쪽 들여쓰기 단계는 2단계이다.
  - 이 안에서 다시 대괄호를 사용하는 구문을 사용하면 안 된다.
  - C# 코딩 컨벤션에서는 들여쓰기 1번에 공백 4칸을 사용하도록 규정하고 있으므로, 들여쓰기 2단계는 공백 8칸이다.
  - 아예 들여쓰기를 하지 않는 것은 컨벤션 위반으로 간주한다.
- 각 메소드의 길이는 최대 20줄을 넘지 않아야 한다.
  - 15줄을 넘기지 않으면 더욱 좋다.
  - 빈 줄은 코드 길이에 포함하지 않는다.
  - 다만 빈 줄은 1줄만 허용한다.
- `else`를 사용하지 않는다.
- `switch/case`를 사용하지 않는다.
- 각 메소드 구현이 완료될 때마다 `git commit`을 수행한다.
- Microsoft에서 제시하는 [C# 코딩 컨벤션](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)을 준수한다.

## 힌트

- 지난번 과제처럼 코드를 가능한 한 잘게 쪼개는 것이 요령이다.
- 모든 로직이 하나의 클래스에 집중될 필요는 없다.
  - 예를 들어, 자동차의 전진 여부를 판단하는 로직이 굳이 자동차 클래스에 있을 필요는 없다.
  - 자동차의 전진 여부를 판단하는 로직이 있는 클래스에서 각 자동차 인스턴스에 전진하도록 메시지를 보내는 것이다.
  - 그러면 각 자동차 객체는 자기 이름과 위치라는 2가지 상태만 기억하면 된다. 이는 초기 코드에 미리 준비되어 있다.
  - 인스턴스에 메시지를 보내는 것 == 그 인스턴스의 메소드를 호출하는 것임을 명심하자.
- 캡슐화(Encapsulation)를 항상 염두에 두자.
  - 캡슐화가 잘 되어 있어야 각 객체의 역할과 책임을 명확하게 구분할 수 있고, 객체간의 협력이 원활하게 이루어질 수 있다.
  - 객체의 행동이 상태를 결정하므로, 코드를 설계할 때 상태보다 행동부터 먼저 생각하는 편이 좋다.
  - 어떤 행동이 필요한지 먼저 결정한 다음 어느 객체가 그 행동을 하는 것이 좋을지 정하고, 거기에 따라 각 객체에 필요한 상태를 최소한도로 부여하는 것이다.
  - 메소드는 어떻게(how) 해야 하는가보다 무엇을(what) 해야 하는지가 드러나야 한다. 메소드 호출을 어떻게 처리할 것인지는 해당 객체가 알아서 해야 할 문제다.
  - 묻지 말고 시켜라 원칙(Law of Demeter): 가능하면 다른 객체의 상태를 일일이 물어보지 말고, 원하는 것을 바로 메시지로 전달해야 한다.
- 과제가 어렵다면, 먼저 비기능적 요구사항은 무시하고 기능만 구현한 다음 이를 비기능적 요구사항에 맞게 하나씩 고쳐 보자.
- 스스로 생각해 봐도 잘 풀리지 않는 문제가 있다면 강사에게 바로바로 물어보자.
